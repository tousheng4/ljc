# [例1：One Time Swap](https://vjudge.net/contest/617068#problem/C)
+ 给你一个字符串，交换位置i，j上的字母（1<=i<j<=n）,问交换后生成的新的字符串有多少种不一样的
- 法一：统计每个字母的个数，$$\sum_{i=0}^{25}$$当前字母个数*（总个数-当前字母个数），由于每个都统计了两遍，所以要cnt除2，考虑到还未统计与原串相同的字符串，只要存在一个字母个数大于等于2，cnt就加一
```
#include <bits/stdc++.h>
using namespace std;
string s;
long long cnt=0;
long long m[30];
int main(){
    cin >> s;
    int n=s.size();
    for (int i=0;i<n;i++){
        m[s[i]-'a']++;
    }
    for (int i=0;i<26;i++){
        cnt+=m[i]*(n-m[i]); //当前字母与不同的字母交换产生的不同字符串个数
    }
    cnt=cnt/2;
    for (int i=0;i<26;i++){
        if (m[i]>=2) {  //只要有一个字母个数大于等于2，不论怎么交换都还是原串，所以只需要加一个1
            cnt++;
            break;
        }
    }
    printf("%lld",cnt);
    return 0;
}
```
